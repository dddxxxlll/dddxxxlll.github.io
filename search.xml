<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS同步与异步]]></title>
      <url>%2F2018%2F03%2F06%2FJS%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[JS同步与异步以及promise为什么比settimeout先执行 同步与异步12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; console.log( &quot;1&quot; ); setTimeout(function() &#123; console.log( &quot;2&quot; ) &#125;, 0 ); setTimeout(function() &#123; console.log( &quot;3&quot; ) &#125;, 0 ); setTimeout(function() &#123; console.log( &quot;4&quot; ) &#125;, 0 ); console.log( &quot;5&quot; );&lt;/script&gt; 执行结果为15234结论：js先执行同步任务后才执行异步任务。因为js是单线程的，所有任务都必须排队执行，所以如果前一个任务耗时很长，后一个任务就不得不等待。所以就有了任务队列的概念，将异步任务放入任务队列，只有在主线程完成了所有的同步任务后才进入任务队列的任务。 JS异步运行机制 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 setTimeout与promise12345678setTimeout(function () &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; resolve();&#125;).then(function () &#123; console.log(2);&#125;); 虽然setTimeout先加入任务队列但结果仍然是21总结来说，promise函数进入的是PromiseJobs的任务队列，而setTimeout进入的是ScriptJobs的任务队列。当同步任务执行完，会先进入promise的任务队列，结束以后才进入setTimeout的任务队列。至于为何promise队列的优先级高，估计是为了用户体验吧:)自己的理解，请勿转载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的arguments]]></title>
      <url>%2F2018%2F03%2F05%2FJS%E4%B8%AD%E7%9A%84argument%2F</url>
      <content type="text"><![CDATA[arguments以及caller与arguments.callee argument说明： 在JavaScript中，arguments是对象的一个特殊属性。arguments对象就像数组，但是它却不是数组。属性： length：获取arguments对象的长度。（函数实参长度） callee：引用当前正在执行的函数（callee也有length属性，为函数形参长度） 隐藏参数 123456789function abc(x,y)&#123; alert(x+&quot;,&quot;+y); for(var i=0;i&lt;=arguments.length;i+=)&#123; alert(&quot; &quot;+arguments[i]); &#125;&#125;abc(1,2,3)//output:1,2//output:1 2 3 改变参数值 123456function abc(x,y,z)&#123; arguments[2] = &quot;hello&quot;; for(var i=0;i&lt;=arguments.length;i+=)&#123; alert(&quot; &quot;+arguments[i]); &#125;&#125;//output: 1 2 hello 递归 12345678910求1到n的自然数之和function add(x)&#123; if(x == 1) return 1; else return n + arguments.callee(n-1);&#125;//其实callee对于匿名函数调用自身时就是一个福音了,比如对于没有命名的函数求1到n自然数之和var result = function(x)&#123; if(x == 1) return 1; return x+arguments.callee(x-1);&#125; caller 说明返回一个对函数的引用，该函数调用了当前函数。functionName.callerfunctionName 对象是所执行函数的名称。如果是顶层对象调用该functionName函数，则caller为null callee见上面的递归。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS数组与对象的合并]]></title>
      <url>%2F2018%2F02%2F28%2FJS%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%88%E5%B9%B6%2F</url>
      <content type="text"><![CDATA[Js数组与对象的合并、深拷贝、对象类型的判断 数组合并 concat方法 1234var a=[1,2,3],b=[4,5,6];var c=a.concat(b);console.log(c);// 1,2,3,4,5,6console.log(a);// 1,2,3 不改变本身 循环遍历 12345678var arr1=[&apos;a&apos;,&apos;b&apos;];var arr2=[&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];for(var i=0;i&lt;arr2.length;i++)&#123; arr1.push(arr2[i])&#125;console.log(arr1);//[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] apply 123456var arr1=[&apos;a&apos;,&apos;b&apos;];var arr2=[&apos;c&apos;,&apos;d&apos;,&apos;e&apos;];Array.prototype.push.apply(arr1,arr2);//或者arr1.push.apply(arr1,arr2);&lt;br&gt;console.log(arr1) //[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;] 对象的合并 $.extend() 123456var obj1= &#123;&apos;a&apos;: 1&#125;;var obj2= &#123;&apos;b&apos;: 1&#125;;var c = $.extend(obj1, obj2);console.log(obj1); // &#123;a: 1, b: 1&#125; obj1已被修改//或者 &lt;br&gt;var obj3 = $.extend(&#123;&#125;, obj1, obj2) &lt;br&gt;console.log(obj3); //&#123;a: 1, b: 1&#125; 不会改变obj1,obj2 遍历赋值 123456789var obj1=&#123;&apos;a&apos;:1&#125;;var obj2=&#123;&apos;b&apos;:2,&apos;c&apos;:3&#125;;for(var key in obj2)&#123; if(obj2.hasOwnProperty(key)===true)&#123; &lt;br&gt; //此处hasOwnProperty是判断自有属性，使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问会避免原型对象扩展带来的干扰 obj1[key]=obj2[key]; &#125;&#125;console.log(obj1);//&#123;&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3&#125;; Obj.assign()Object.assign(target, …sources)assign后来的源的属性会覆盖早先的源的属性assign不是深拷贝，如果源对象的属性是一个指向对象的引用，他会只拷贝那个引用值（如下） 12345678910111213141516171819202122let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; // Deep Clone obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 另外assign会覆盖原对象1234567var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。 深拷贝123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== &apos;object&apos;)&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //将对象化为字符串 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === &apos;object&apos; ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 对象类型的判断 typeof形如 var x = “xx”; typeof x == ‘string’ typeof(x);返回类型有：’undefined’ “string” ‘number’ ‘boolean’ ‘function’ ‘object’缺点：对于object类型不能细分是什么类型优点：对空null的判断 ‘undefined’的应用 instanceof形如 var d = new String(‘test’); d instanceof String ==true;返回的类型有：String Number Boolean Function Object Array Date优点：能区分出更细的类型如 Date Array 如 var num = 3; num instanceof Number 能返回具体的类型缺点：直变量不能区分 必须采用new 的对象 constructor形如：var x = []; x.constructor==Array;优点：可以返回继承的类型缺点: 不能对象的细分,如继承 必须手动修正 Object.prototype.toString.call();优点：通用，返回”[objectString]” 具体object的类型缺点：不能返回继承的类型 一般先typeof如果返回object再constructor]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[元素黏连特效]]></title>
      <url>%2F2018%2F01%2F04%2F%E5%85%83%E7%B4%A0%E9%BB%8F%E8%BF%9E%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[by zhangxinxu from http://www.zhangxinxu.com/wordpress/?p=6655 黏连效果代码页面任意位置塞入这么一段SVG代码123456789&lt;svg width=&quot;0&quot; height=&quot;0&quot; style=&quot;position:absolute;&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;goo&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;10&quot; result=&quot;blur&quot; /&gt; &lt;feColorMatrix in=&quot;blur&quot; mode=&quot;matrix&quot; values=&quot;1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 19 -9&quot; result=&quot;goo&quot; /&gt; &lt;feComposite in=&quot;SourceGraphic&quot; in2=&quot;goo&quot; operator=&quot;atop&quot;/&gt; &lt;/filter&gt; &lt;/defs&gt;&lt;/svg&gt; 需要黏连元素的父元素css加一句1filter: url(&quot;#goo&quot;); 效果局限 浏览器兼容问题：ie不支持1234var ua = navigator.userAgent;if (/Safari|iPhone/i.test(ua) &amp;&amp; /chrome/i.test(ua) == false) &#123; document.body.classList.add(&apos;nofilter&apos;);&#125; CSS:123body:not(.nofilter) .target &#123; filter: url(&quot;#goo&quot;);&#125; 该效果只适用于圆形元素 DEMOa link]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js内存泄漏详解]]></title>
      <url>%2F2017%2F12%2F05%2FJs%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%2F</url>
      <content type="text"><![CDATA[Js内存泄漏的几种情况与解决方法。 意外的全局变量JavaScript 对未声明变量的处理方式：在全局对象上创建该变量的引用(即全局对象上的属性，不是变量，因为它能通过delete删除)。如果在浏览器中，全局对象就是window对象。 如果未声明的变量缓存大量的数据，会导致这些数据只有在窗口关闭或重新刷新页面时才能被释放。这样会造成意外的内存泄漏。123function foo(arg) &#123; bar = &quot;this is a hidden global variable with a large of data&quot;;&#125; 等同于：123function foo(arg) &#123; window.bar = &quot;this is an explicit global variable with a large of data&quot;;&#125; 另外，通过this创建意外的全局变量：123456function foo() &#123; this.variable = &quot;potential accidental global&quot;;&#125;// 当在全局作用域中调用 foo 函数，此时 this 指向的是全局对象(window)，而不是&apos;undefined&apos;foo(); 解决方法： 在 JavaScript 文件中添加’use strict’，开启严格模式，可以有效地避免上述问题。1234function foo(arg) &#123; &quot;use strict&quot; // 在 foo 函数作用域内开启严格模式 bar = &quot;this is an explicit global variable with a large of data&quot;;// 报错：因为 bar 还没有被声明&#125; console.logconsole.log：向 web 开发控制台打印一条消息，常用来在开发时调试分析。有时在开发时，需要打印一些对象信息，但发布时却忘记去掉console.log语句，这可能造成内存泄露。 在传递给console.log的对象是不能被垃圾回收 ♻️，因为在代码运行之后需要在开发工具能查看对象信息。所以最好不要在生产环境中console.log任何对象。 closures(闭包)当一个函数 A 返回一个内联函数 B，即使函数 A 执行完，函数 B 也能访问函数 A 作用域内的变量，这就是一个闭包——本质上闭包是将函数内部和外部连接起来的一座桥梁。12345678910function foo(message) &#123; function closure() &#123; console.log(message) &#125;; return closure;&#125;// 使用var bar = foo(&quot;hello closure!&quot;);bar()// 返回 &apos;hello closure!&apos; 在函数 foo 内创建的函数 closure 对象是不能被回收掉的，因为它被全局变量 bar 引用，处于一直可访问状态。通过执行bar()可以打印出hello closure!。如果想释放掉可以将bar = null即可。 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。 DOM 泄露在 JavaScript 中，DOM 操作是非常耗时的。因为 JavaScript/ECMAScript 引擎独立于渲染引擎，而 DOM 是位于渲染引擎，相互访问需要消耗一定的资源。如 Chrome 浏览器中 DOM 位于 WebCore，而 JavaScript/ECMAScript 位于 V8 中。假如将 JavaScript/ECMAScript、DOM 分别想象成两座孤岛，两岛之间通过一座收费桥连接，过桥需要交纳一定“过桥费”。JavaScript/ECMAScript 每次访问 DOM 时，都需要交纳“过桥费”。因此访问 DOM 次数越多，费用越高，页面性能就会受到很大影响。 为了减少 DOM 访问次数，一般情况下，当需要多次访问同一个 DOM 方法或属性时，会将 DOM 引用缓存到一个局部变量中。但如果在执行某些删除、更新操作后，可能会忘记释放掉代码中对应的 DOM 引用，这样会造成 DOM 内存泄露。如以下代码：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Dom-Leakage&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;remove&quot; class=&quot;remove&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;add&quot; class=&quot;add&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;pre class=&quot;wrapper&quot;&gt;&lt;/pre&gt; &lt;/div&gt; &lt;script&gt; // 因为要多次用到&lt;pre&gt;节点，将其缓存到本地变量 wrapper 中， var wrapper = document.querySelector(&apos;.wrapper&apos;); var counter = 0; document.querySelector(&apos;.remove&apos;).addEventListener(&apos;click&apos;, function () &#123; document.querySelector(&apos;.container&apos;).removeChild(wrapper); &#125;, false); document.querySelector(&apos;.add&apos;).addEventListener(&apos;click&apos;, function () &#123; wrapper.appendChild(document.createTextNode(&apos;\t&apos; + ++counter + &apos;：a new line text\n&apos;)); &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 导致整个pre元素和新增节点无法别回收的原因是：代码中存在全局变量wrapper对pre元素的引用。解决方法：在删除逻辑中释放全局变量，增加wrapper = null;语句。 timers很明显，当setInterval后没有清除定时器将会导致函数不断重复运行。 EventListener做移动开发时，需要对不同设备尺寸做适配。如在开发组件时，有时需要考虑处理横竖屏适配问题。一般做法，在横竖屏发生变化时，需要将组件销毁后再重新生成。而在组件中会对其进行相关事件绑定，如果在销毁组件时，没有将组件的事件解绑，在横竖屏发生变化时，就会不断地对组件进行事件绑定。这样会导致一些异常，甚至可能会导致页面崩掉。 同一个元素节点注册了多个相同的 EventListener，那么重复的实例会被抛弃。这么做不会让得 EventListener 被重复调用，也不需要用 removeEventListener 手动清除多余的 EventListener，因为重复的都被自动抛弃了。而这条规则只是针对于命名函数。对于匿名函数，浏览器会将其看做不同的 EventListener，所以只要将匿名的 EventListener，命名一下就可以解决问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DragModel——可拖动模态框]]></title>
      <url>%2F2017%2F08%2F15%2FDragModel%E2%80%94%E2%80%94%E5%8F%AF%E6%8B%96%E5%8A%A8%E6%A8%A1%E6%80%81%E6%A1%86%2F</url>
      <content type="text"><![CDATA[实现功能： 模态框可拖动 在模态框中打开模态框时，下面的模态框不可点击 在线地址：https://dddxxxlll.github.io/DragModel/ 使用方法： open_s(id_to, id_from)：第一个参数为要打开的目标模态框id，第二个参数为从哪个模态框打开 close_s(id_this, id_to)：第一个参数为要关闭的模态框（当前模态框）id，第二个参数为关闭当前模态框后要前往的模态框123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #app_content span&#123;display:inline-block;width:130px;text-align:right;&#125; #app_content div a&#123;display:inline-block;margin-left:10px;&#125; #app_content&gt;div&#123;height:55px;line-height:55px;&#125; .cover&#123;width:10000px;height:10000px;background:rgba(200,200,200,0.3);position:absolute;z-index:1050;top:0px;left:0px;&#125; /*modal*/ .closeBtn3&#123; cursor:pointer; width:30px; height:30px; border-radius:15px; background:#fff; color:#00a0e9; border:1px solid #00a0e9; position:absolute; top:-10px; line-height:30px; right:-10px &#125; .modalHeader&#123; background:rgb(40,134,250); color:#fff; position:relative; text-align:center; border-radius:8px 8px 0 0; height:45px; line-height:45px; font-size:18px; &#125; .modalFooter&#123; margin:0 auto &#125; .modalFooter &gt; div&#123; width:150px; text-align:center; border-radius:4px; cursor:pointer; margin-top:7px; height:35px; line-height:35px; border:1px solid #399BFF; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=&quot;add_app()&quot;&gt;打开模态框&lt;/button&gt;&lt;!-- 弹出框 --&gt;&lt;div id=&quot;application&quot; class=&quot;modal&quot; style=&quot;display:none;position:fixed;top:0;left:0;height:100%;width:100%;background:rgba(0,0,0,0.3)&quot;&gt; &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app_detail&quot; style=&quot;width:700px;height:400px;position:absolute;left:50%;top:50%;transform: translate3d(-50%, -50%, 0px);background:#fff;border-radius: 8px;z-index:1060;&quot;&gt; &lt;div class=&quot;modalHeader&quot; style=&quot;width:100%;text-align:center;&quot;&gt; &lt;em class=&quot;&quot; style=&quot;font-size:20px&quot;&gt;添加应用&lt;/em&gt; &lt;div class=&quot;closeBtn3&quot; onclick=&quot;close_sp(&apos;#application&apos;,&apos;#app_detail&apos;)&quot; style=&quot;text-align:center&quot;&gt;X&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modalContent&quot; id=&quot;app_content&quot; style=&quot;height: 280px;&quot;&gt; &lt;div&gt;&lt;span&gt;应用名：&lt;/span&gt;&lt;input type=&quot;text&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;应用描述：&lt;/span&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;/div&gt; &lt;div&gt;&lt;span&gt;选择服务：&lt;/span&gt;&lt;a style=&quot;cursor:pointer;color: #428bca;text-decoration: none;&quot; onclick=&quot;open_s(&apos;#servers_detail&apos;,&apos;#app_detail&apos;)&quot; id=&quot;recipient_show&quot;&gt;请选择&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modalFooter&quot; style=&quot;border-top:1px solid #ccc; overflow: hidden;margin-top:21px;&quot;&gt; &lt;div onclick=&quot;&quot; style=&quot;float:right;margin-right:70px;background:#399BFF;color:#fff;&quot;&gt;确认&lt;/div&gt; &lt;div onclick=&quot;close_sp(&apos;#application&apos;,&apos;#app_detail&apos;)&quot; style=&quot;float:left;margin-left:70px;&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;servers_detail&quot; style=&quot;display:none;width:700px;height:400px;position:absolute;left:50%;top:50%;transform: translate3d(-50%, -50%, 0px);background:#fff;border-radius: 8px;z-index:1060;&quot;&gt; &lt;div class=&quot;modalHeader&quot; style=&quot;width:100%;text-align:center;&quot;&gt; &lt;em class=&quot;&quot; style=&quot;font-size:20px&quot;&gt;添加应用&lt;/em&gt; &lt;div class=&quot;closeBtn3&quot; onclick=&quot;close_s(&apos;#servers_detail&apos;,&apos;#app_detail&apos;)&quot; style=&quot;text-align:center&quot;&gt;X&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modalContent&quot; style=&quot;height: 304px;padding: 0 20px;width: 660px;&quot;&gt; &lt;div class=&quot;table app&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modalFooter&quot; style=&quot;border-top:1px solid #ccc; overflow: hidden;&quot;&gt; &lt;div onclick=&quot;close_s(&apos;#servers_detail&apos;,&apos;#app_detail&apos;)&quot; style=&quot;float:right;margin-right:70px;background:#399BFF;color:#fff;&quot;&gt;确认&lt;/div&gt; &lt;div onclick=&quot;close_s(&apos;#servers_detail&apos;,&apos;#app_detail&apos;)&quot; style=&quot;float:left;margin-left:70px;&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; function add_app()&#123; $(&apos;#application&apos;).css(&apos;display&apos;,&apos;block&apos;); /* 增加拖动 */ $(&quot;#app_detail&quot;).addClass(&apos;adddrag&apos;); $(&quot;#app_detail .modalHeader&quot;).addClass(&apos;dragarea&apos;); drag(); &#125; //模态框方法 function open_s(id,idfrom)&#123; $(id).css(&quot;display&quot;,&quot;block&quot;); $(id).css(&quot;z-index&quot;,&quot;1060&quot;); $(idfrom).css(&quot;z-index&quot;,&quot;1&quot;); $(&quot;.cover&quot;).css(&quot;display&quot;,&quot;block&quot;); $(idfrom).removeClass(&apos;adddrag&apos;); $(idfrom+&quot; .modalHeader&quot;).removeClass(&apos;dragarea&apos;); $(id).addClass(&apos;adddrag&apos;); $(id+&quot; .modalHeader&quot;).addClass(&apos;dragarea&apos;); drag(); &#125; function close_s(id,idto)&#123; $(id).css(&quot;display&quot;,&quot;none&quot;); $(id).css(&quot;z-index&quot;,&quot;1&quot;); $(idto).css(&quot;z-index&quot;,&quot;1060&quot;); $(id).removeClass(&apos;adddrag&apos;); $(id+&quot; .modalHeader&quot;).removeClass(&apos;dragarea&apos;); $(idto).addClass(&apos;adddrag&apos;); $(idto+&quot; .modalHeader&quot;).addClass(&apos;dragarea&apos;); drag(); &#125; function close_sp(id,id2)&#123; $(id).css(&quot;display&quot;,&quot;none&quot;); $(id2).removeClass(&apos;adddrag&apos;); $(id2+&quot; .modalHeader&quot;).removeClass(&apos;dragarea&apos;); &#125; //拖动函数 function drag() &#123; var oDiv = document.getElementsByClassName(&apos;adddrag&apos;)[0]; var oDiv2 = document.getElementsByClassName(&apos;dragarea&apos;)[0]; // var b = $(&apos;.infoBox&apos;)[0]; oDiv2.onmousedown = function(ev)&#123; var ev = ev || event; var disX = ev.clientX - oDiv.offsetLeft; var disY = ev.clientY - oDiv.offsetTop; if(oDiv2.setCapture)&#123; oDiv2.setCapture(); &#125; document.onmousemove = function(ev)&#123; //这里为什么使用document，是因为快速拖拽的话会鼠标丢失， var ev = ev || event; oDiv.style.left = ev.clientX - disX+&quot;px&quot;; oDiv.style.top = ev.clientY - disY+&quot;px&quot;; &#125; document.onmouseup = function(ev)&#123; document.onmousemove = document.onmouseup = null; //为何不用oDiv.onmouseup是因为被挡住之后会无视掉遮挡的元素 if(oDiv2.releaseCapture)&#123; oDiv2.releaseCapture(); &#125; &#125; return false; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongodb的populate的用法]]></title>
      <url>%2F2017%2F08%2F07%2FMongodb%E7%9A%84populate%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Mongodb的populate的用法1234567891011121314151617181920212223var mongoose = require(&apos;mongoose&apos;);var Schema = mongoose.Schema;var UserSchema = new Schema(&#123; name : &#123; type: String, unique: true &#125;, posts : [&#123; type: Schema.Types.ObjectId, ref: &apos;Post&apos; &#125;]&#125;);var User = mongoose.model(&apos;User&apos;, UserSchema);var PostSchema = new Schema(&#123; poster : &#123; type: Schema.Types.ObjectId, ref: &apos;User&apos; &#125;, comments : [&#123; type: Schema.Types.ObjectId, ref: &apos;Comment&apos; &#125;], title : String, content : String&#125;);var Post = mongoose.model(&apos;Post&apos;, PostSchema);var CommentSchema = new Schema(&#123; post : &#123; type: Schema.Types.ObjectId, ref: &quot;Post&quot; &#125;, commenter : &#123; type: Schema.Types.ObjectId, ref: &apos;User&apos; &#125;, content : String&#125;);var Comment = mongoose.model(&apos;Comment&apos;, CommentSchema); 在上述的例子中，创建了三个 Models:User，Post，Comment。 User 的属性 posts，对应是一个 ObjectId 的数组。ref表示关联Post(注意: 被关联的model的 type 必须是ObjectId, Number, String, 和 Buffer 才有效)。 Post的属性 poster 和 comments 分别关联User和Comment。 Comment的属性 post 和 commenter 分别关联Post和User。 三个 Models 的关系:一个 user–has many–&gt;post。一个 post–has one–&gt;user，has many–&gt;comment。一个 comment–has one–&gt;post 和 user。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 连接数据库mongoose.connect(&apos;mongodb://localhost/population-test&apos;, function (err)&#123; if (err) throw err; createData();&#125;);function createData() &#123; var userIds = [new ObjectId, new ObjectId, new ObjectId]; var postIds = [new ObjectId, new ObjectId, new ObjectId]; var commentIds = [new ObjectId, new ObjectId, new ObjectId]; var users = []; var posts = []; var comments = []; users.push(&#123; _id : userIds[0], name : &apos;aikin&apos;, posts : [postIds[0]] &#125;); users.push(&#123; _id : userIds[1], name : &apos;luna&apos;, posts : [postIds[1]] &#125;); users.push(&#123; _id : userIds[2], name : &apos;luajin&apos;, posts : [postIds[2]] &#125;); posts.push(&#123; _id : postIds[0], title : &apos;post-by-aikin&apos;, poster : userIds[0], comments : [commentIds[0]] &#125;); posts.push(&#123; _id : postIds[1], title : &apos;post-by-luna&apos;, poster : userIds[1], comments : [commentIds[1]] &#125;); posts.push(&#123; _id : postIds[2], title : &apos;post-by-luajin&apos;, poster : userIds[2], comments : [commentIds[2]] &#125;); comments.push(&#123; _id : commentIds[0], content : &apos;comment-by-luna&apos;, commenter : userIds[1], post : postIds[0] &#125;); comments.push(&#123; _id : commentIds[1], content : &apos;comment-by-luajin&apos;, commenter : userIds[2], post : postIds[1] &#125;); comments.push(&#123; _id : commentIds[2], content : &apos;comment-by-aikin&apos;, commenter : userIds[1], post : postIds[2] &#125;); User.create(users, function(err, docs) &#123; Post.create(posts, function(err, docs) &#123; Comment.create(comments, function(err, docs) &#123; &#125;); &#125;); &#125;);&#125; Query#populate的语法 语法：Query.populate(path, [select], [model], [match], [options]) 参数：path 类型：String或Object。 String类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。 Object类型的时，就是把 populate 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。 select 类型：Object或String，可选，指定填充 document 中的哪些字段。 Object类型的时，格式如:{name: 1, _id: 0},为0表示不填充，为1时表示填充。 String类型的时，格式如:”name -_id”，用空格分隔字段，在字段名前加上-表示不填充。详细语法介绍query-select model 类型：Model，可选，指定关联字段的 model，如果没有指定就会使用Schema的ref。 match 类型：Object，可选，指定附加的查询条件。 options 类型：Object，可选，指定附加的其他查询选项，如排序以及条数限制等等。 123456789101112User.findOne(&#123;name: &apos;aikin&apos;&#125;) .exec(function(err, doc) &#123; var opts = [&#123; path : &apos;posts&apos;, select : &apos;title&apos; &#125;]; doc.populate(opts, function(err, populatedDoc) &#123; console.log(populatedDoc.posts[0].title); // post-by-aikin &#125;); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Websocket通俗易懂的原理解释]]></title>
      <url>%2F2017%2F06%2F07%2FWebsocket%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%2F</url>
      <content type="text"><![CDATA[看node的时候偶尔发现的博文，原出处找不到了。属于真通俗易懂，世界上多一点这种教程该有多好！ 一、Websocket与httpWebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算） 首先HTTP有 1.1 和 1.0 之说，也就是所谓的 keep-alive ，把多个HTTP请求合并为一个，但是 Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解 有交集，但是并不是全部。 另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。通俗来说，你可以用HTTP协议传输非Html数据，就是这样=。= 再简单来说，层级不一样。 二、Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。 HTTP的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次HTTP请求就结束了。 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 教练，你BB了这么多，跟Websocket有什么关系呢？(:з」∠)好吧，我正准备说Websocket呢。。 首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。 首先我们来看个典型的 Websocket 握手（借用Wikipedia的。。）12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。我会顺便讲解下作用。12Upgrade: websocketConnection: Upgrade 这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。123Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。 然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~ 最后， Sec-WebSocket-Version 是告诉服务器所使用的 Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用的一个东西~ 脱水： 服务员，我要的是13岁的噢→_→ 然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~12Upgrade: websocketConnection: Upgrade 依然是固定的，告诉客户端即将升级的是 Websocket 协议，而不是mozillasocket，lurnarsocket或者shitsocket。 然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。 后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。 至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。具体的协议就不在这阐述了。 ——————技术解析部分完毕—————— 你TMD又BBB了这么久，那到底Websocket有什么鬼用， http long poll ，或者ajax轮询 不都可以实现实时信息传递么。 好好好，年轻人，那我们来讲一讲Websocket有什么用。来给你吃点胡（苏）萝（丹）卜（红） 三、Websocket的作用在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。 ajax轮询ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 场景再现： 客户端：啦啦啦，有没有新信息(Request) 服务端：没有（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：没有。。（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：你好烦啊，没有啊。。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） —- loop long polllong poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 场景再现： 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） 服务端：额。。 等待到有消息的时候。。来 给你（Response） 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop 从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。 何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。 简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。 说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ） 从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。 ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小） 所以 ajax轮询 和 long poll 都有可能发生这种情况。 客户端：啦啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：。。。。好吧，啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：然后服务端在一旁忙的要死：冰箱，我要更多的冰箱！更多。。更多。。（我错了。。这又是梗。。） 言归正传，我们来说Websocket吧通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。 一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。 哦对了，忘记说了HTTP还是一个状态协议。 通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。 所以在这种情况下出现了，Websocket出现了。他解决了HTTP的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。所以上面的情景可以做如下修改。 客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request） 服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched） 客户端：麻烦你有信息的时候推送给我噢。。 服务端：ok，有的时候会告诉你的。 服务端：balabalabalabala 服务端：balabalabalabala 服务端：哈哈哈哈哈啊哈哈哈哈 服务端：笑死我了哈哈哈哈哈哈哈 就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你 ） 这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。那么为什么他会解决服务器上消耗资源的问题呢？ 其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。简单地说，我们有一个非常快速的 接线员（Nginx） ，他负责把问题转交给相应的 客服（Handler） 。 本身接线员基本上速度是足够的，但是每次都卡在客服（Handler）了，老有客服处理速度太慢。，导致客服不够。Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。 这样就可以解决客服处理速度过慢的问题了。 同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。 虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。 但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。 同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了 ——————– 至于怎么在不支持Websocket的客户端上使用Websocket。。答案是： 不能 但是可以通过上面说的 long poll 和 ajax 轮询 来 模拟出类似的效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爱奇艺优酷免vip方法]]></title>
      <url>%2F2017%2F05%2F26%2F%E7%88%B1%E5%A5%87%E8%89%BA%E4%BC%98%E9%85%B7%E5%85%8Dvip%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[手把手教你怎么免费看爱奇艺等视频网站 方法一：直接下载VIP.html文档，双击打开。将视频地址输入，然后点击播放下载地址ps：可以随手star我easy！ 不会下载？ PC端直接以下步骤，手机端先点击右下角Desktop version（ps：手机端还是别搞这个东西了） 点击右上clone and download 选择download zip 然后解压。 方法二：（没有上方的按钮组，看视频更美观）chrome商店下载tampermonkey插件（一直在用的插件，如果没有的话就别用这个方法了）添加新脚本，将下面代码完全覆盖（其中@match后面跟你要看的视频地址）12345678910111213141516// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match http://v.youku.com/v_show/id_XMjQ4NTczNTE1Ng==.html// @grant none// ==/UserScript==(function() &#123; &apos;use strict&apos;; // Your code here... window.location = &apos;http://p2.api.47ks.com/webcloud/?v=&apos;+window.location.href;&#125;)(); 刷新所要看的网页easy！ 方法三：（最简单，最方便，最优解，不用输入网址）打开任意浏览器。打开任意网页，ctrl+D保存为书签修改该书签地址为以下代码：1javascript:window.location = &apos;http://p2.api.47ks.com/webcloud/?v=&apos;+window.location.href 然后打开任意你想看的视频页面点击该书签，完工！easy！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中This的详解]]></title>
      <url>%2F2017%2F05%2F08%2FJS%E4%B8%ADThis%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[从绑定This的四种方式来全面解析JS中的This。资料来源于You Don’t Know JS系列丛书感谢作者的开源以及YDKJS的中文翻译 默认绑定（Default Binding）第一种This绑定规则可以认为是没有其他规则适用时的默认规则。考虑下面这个代码段：12345function foo() &#123; console.log( this.a );&#125;var a = 2;foo(); // 2 独立函数的调用，无其他规则适用，所以This被绑定到全局对象。 要注意的是默认绑定在strict模式下是不合法的。此时的This将会返回undefined 如果函数内容没有在严格模式中运行，即使他在严格模式的上下文中被调用，this依旧能返回全局对象。（当然，应该尽量避免使用严格和非严格模式混合） 隐含绑定（Implicit Binding）当函数调用点有一个环境对象（context object），也称为拥有者（owning）或容器（containing）对象则他将被隐含绑定到该对象。考虑下面这段代码：12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); // 2 当他是被这样调用时：obj1.obj2.foo();只有obj2时影响调用点的。 隐含绑定的丢失当一个隐含绑定丢失，则他将会退回默认绑定。1234567891011121314function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数引用！var a = &quot;oops, global&quot;; // `a`也是一个全局对象的属性bar(); // &quot;oops, global&quot; 尽管bar似乎是obj.foo的引用，但实际上他知识foo的一个引用。这样就很好理解了：bar()就等同于foo()。显然符合默认绑定考虑回调函数：1234567891011121314151617function foo() &#123; console.log( this.a );&#125;function doFoo(fn) &#123; // `fn` 只不过`foo`的另一个引用 fn(); // &lt;-- 调用点!&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = &quot;oops, global&quot;; // `a`也是一个全局对象的属性doFoo( obj.foo ); // &quot;oops, global&quot; 与上面一样，fn知识foo的一个引用。而下面的明确绑定将解决隐含绑定的丢失。 明确绑定（Explicit Binding）很简单，就是通过call，apply，bind方法将this绑定到某一个环境上下文中其中call、apply类似，他们将会立刻调用函数，而bind不会。 new绑定（new Binding）考虑下面的代码：123456function foo(a) &#123; this.a = a;&#125;var bar = new foo( 2 );console.log( bar.a ); // 2 通过在前面使用new来调用foo(..)，我们构建了一个新的对象并这个新对象作为foo(..)调用的this。 new是函数调用可以绑定this的最后一种方式，我们称之为 new绑定（new binding）。 四种绑定的顺序bind绑定高于new，明确绑定高于隐含绑定高于默认绑定 判定this 函数是和new一起被调用的吗（new绑定）？如果是，this就是新构建的对象。var bar = new foo() 函数是用call或apply被调用（明确绑定），甚至是隐藏在bind 硬绑定 之中吗？如果是，this就是明确指定的对象。var bar = foo.call( obj2 ) 函数是用环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this就是那个环境对象。var bar = obj1.foo() 否则，使用默认的this（默认绑定）。如果在strict mode下，就是undefined，否则是global对象。var bar = foo()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS content换行技术实现字符loading效果]]></title>
      <url>%2F2017%2F04%2F12%2FCSS-content%E6%8D%A2%E8%A1%8C%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6loading%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[偶然从张鑫旭大神博客看来的技巧很巧妙的运用before伪类以及content的换行实现的loading…效果 dot { display: inline-block; height: 1em; line-height: 1; vertical-align: -.25em; overflow: hidden; } dot::before { display: block; content: '...\A..\A.'; white-space: pre-wrap; animation: dot 3s infinite step-start both; } @keyframes dot { 33% { transform: translateY(-2em); } 66% { transform: translateY(-1em); } } .grebtn { display: inline-block; width: 100px; height: 20px; border: 1px solid #000; line-height:20px; text-align: center; margin: 0 5px; } css代码如下：1234567891011121314151617dot &#123; display: inline-block; height: 1em; line-height: 1; text-align: left; vertical-align: -.25em; overflow: hidden;&#125;dot::before &#123; display: block; content: &apos;...\A..\A.&apos;; white-space: pre-wrap; /* 也可以是white-space: pre */ animation: dot 3s infinite step-start both;&#125;@keyframes dot &#123; 33% &#123; transform: translateY(-2em); &#125; 66% &#123; transform: translateY(-1em); &#125;&#125; html代码：1loading&lt;dot&gt;...&lt;/dot&gt; 简要分析 content中的\A指的是换行符中的LF字符，CR字符在content中用\D表示 animation很简单没什么好说的，其实实际就是点的三种形态分三行来显示，overflow来隐藏多余的点，动画来变化显示的点，很聪明的实现方法！ 其他拓展：content: &quot;/\A–\A\\\A|&quot;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生js实现div拖拽并在任意位置放下]]></title>
      <url>%2F2017%2F04%2F11%2F%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0div%E6%8B%96%E6%8B%BD%E5%B9%B6%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%94%BE%E4%B8%8B%2F</url>
      <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; #main&#123;width:100px;height:100px;background:#ffccff;position:absolute;&#125;&lt;/style&gt;&lt;script&gt; /*1：拖拽的时候有文字选中会有问题； 原因：这是浏览器的默认拖拽文字的行为 解决方案：标准浏览器下：阻止默认行为,在onmousedown结尾加上return false即可 ie8及其以下版本：设置全局捕获，方法如下设置全局捕获setCapture最后释放releaseCapture*/ window.onload = function()&#123; var oDiv = document.getElementById(&quot;main&quot;); var odiv = document.getElementById(&quot;div&quot;); oDiv.onmousedown = function(ev)&#123; var ev = ev || event; var disX = ev.clientX - this.offsetLeft; var disY = ev.clientY - this.offsetTop; if(oDiv.setCapture)&#123; oDiv.setCapture(); &#125; document.onmousemove = function(ev)&#123; //这里为什么使用document，是因为快速拖拽的话会鼠标丢失， var ev = ev || event; oDiv.style.left = ev.clientX - disX+&quot;px&quot;; oDiv.style.top = ev.clientY - disY+&quot;px&quot;; &#125; document.onmouseup = function(ev)&#123; document.onmousemove = document.onmouseup = null; //为何不用oDiv.onmouseup是因为被挡住之后会无视掉遮挡的元素 if(oDiv.releaseCapture)&#123; oDiv.releaseCapture(); &#125; &#125; return false; &#125; &#125; var aaa = function()&#123;document.getElementById(&apos;aaa&apos;).style.display=&apos;block&apos;;&#125;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt; 关于SetCapture()函数定义：该函数属于当前线程的指定窗口里设置鼠标捕获。一旦窗口捕获了鼠标，所有鼠标输入都针对该窗口，无论光标是否在窗口的边界内。同一时刻只能有一个窗口捕获鼠标。如果鼠标光标在另一个线程创建的窗口上，只有当鼠标键按下时系统才将鼠标输入指向指定的窗口。大概作用就是在拖动过程中，可以捕获到浏览器的外的拖动事件。要注意的是，在浏览器外无法捕获到鼠标的点击事件，因为鼠标点击后焦点就在浏览器外的窗口了，原来的SerCapture函数就失效了。 关于releaseCapture()函数SetCapture()与releaseCapture()成对出现，否则别的线程调用就会失败。 关于offsetLeft运用这段代码时出现了错误，反复调用控制台发现offsetLeft并非是元素到浏览器左边的距离，而是元素到第一个最近的定位过的父元素（offsetParent）的距离。如果没有定位过的父元素，则offsetParent为body。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[for/in、for、while、do/while循环和forEach遍历的跳过和中断]]></title>
      <url>%2F2017%2F04%2F07%2Ffor-in%E3%80%81for%E3%80%81while%E3%80%81do-while%E5%BE%AA%E7%8E%AF%E5%92%8CforEach%E9%81%8D%E5%8E%86%E7%9A%84%E8%B7%B3%E8%BF%87%E5%92%8C%E4%B8%AD%E6%96%AD%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788!function () &#123; console.group(&apos;for/in&apos;) var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; for (var i in array) &#123; i++; if (i === 3) &#123; continue; &#125; if (i === 5) &#123; break; &#125; console.log(i); &#125; console.groupEnd(&apos;for/in&apos;)&#125;()!function () &#123; console.group(&apos;for&apos;) for (var i = 0; i &lt; 10;) &#123; i++; if (i === 3) &#123; continue; &#125; if (i === 5) &#123; break; &#125; console.log(i); &#125; console.groupEnd(&apos;for&apos;)&#125;()!function () &#123; console.group(&apos;while&apos;) var i = 0; while (true) &#123; i++; if (i === 3) &#123; continue; &#125; if (i === 5) &#123; break; &#125; console.log(i); &#125; console.groupEnd(&apos;while&apos;)&#125;()!function () &#123; console.group(&apos;do/while&apos;) var i = 0; do &#123; i++; if (i === 3) &#123; continue; &#125; if (i === 5) &#123; break; &#125; console.log(i); &#125; while (i &lt; 10) console.groupEnd(&apos;do/while&apos;)&#125;()!function () &#123; var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // forEach 中 return 等于跳过 array.forEach(function (index, i) &#123; i++; if (i === 3) &#123; return; &#125; console.log(i); &#125;); // some 中 return true 等于中断 array.some(function (index, i) &#123; i++; if (i === 3) &#123; return true; &#125; console.log(i); return false; &#125;); // every 中 return false 等于中断 array.every(function (index, i) &#123; i++; if (i === 3) &#123; return false; &#125; console.log(i); return true; &#125;);&#125;() Console结果：1234567891011121314151617181920212223242526272829for/in124for124while124do/while12412456789101212]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js中闭包等问题（转载）]]></title>
      <url>%2F2017%2F04%2F06%2FJs%E4%B8%AD%E9%97%AD%E5%8C%85%E7%AD%89%E9%97%AE%E9%A2%98%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[第一道闭包问题题目代码及答案123456789101112function fun(n,o) &#123; console.log(o) return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;;&#125;var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined,?,?,?var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,?//问:三行a,b,c的输出分别是什么？` 答案：123//a: undefined,0,0,0//b: undefined,0,1,2//c: undefined,0,1,1 详细解答地址作者：小小沧海 第二道Js函数问题题目代码及答案1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName();// 2getName();// 4Foo().getName();// 1getName();// 1new Foo.getName();// 2new Foo().getName();// 3new new Foo().getName();// 3 详细解答地址作者：小小沧海]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6概要]]></title>
      <url>%2F2017%2F04%2F05%2FECMAScript6%E6%A6%82%E8%A6%81%2F</url>
      <content type="text"><![CDATA[一 let与const let声明变量只在它所在的代码块中有效 let不存在变量提升：只能先声明再使用变量 暂时性死区：只要块级作用域内存在let或const命令，它所声明的变量就不再受外部影响，即使在外定义了相同变量名的全局变量。 不允许重复定义变量 块级作用域：在块级作用域中可以定义函数（5不行），但函数作用范围与let相同 do表达式：块级作用域没有返回值。let aaa = do{};则大括号里面内容有返回值赋给aaa。 const声明一个只读变量，不可更改，所以const声明的变量必须立刻初始化。 const的本质：变量指向的内存地址不可改变，如：const foo={}；foo.prop=123；就可以改变 二 变量的解构赋值 例：let [a,b,c] = [1,2,3]; //a=1,b=2,c=3 不仅可以用于数组还可以用在对象：let {foo,bar} = {foo:’aaa’,bar:’bbb’} 三 字符串的扩展 includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部以上三种都支持第二参数，表示开始搜索的位置（endwith与其他两个相反，参数指的是前xx个字符，第一个字符为1） repeat()：返回一个新字符，表示为原字符重复了n次。例：x.repeat(3) padStart(),padEnd()：字符串补全长度，两个参数：第一个指定字符串最小长度，第二个指定用来补全的字符串。如果第二个参数省略则用空格补全。 模板字符串：用前后两个（`）做标识，变量和js表达式和函数放在（$()）内。 模板编译函数：compile() 四 数值的扩展 Number.isNaN()和Number.isFinite()：判断数值是否为nan/有限，如果是非数值一律为false Number.parseInt()和Number.parseFloat()：将原先的全局对象移植到Number对象。 Number.isInteger()：判断一个数值是否为整数。 Number.EPSILON()：Number对象上增加的一个极小常量。 Number.isSafeInteger()：判断是否超出js数字最大范围。 Math.trunc()：用于去除一个数的小数部分，返回其整数部分。 Math.sign()：用来判断一个数是正数、负数还是零。（正数返回1，负数-1，0两种情况，其它值返回NaN） Math.cbrt()：用于计算一个数的立方根。 Math.clz32()：返回一个数的32位无符号整数形式有多少个前导零。 Math.imul()：计算大数值相乘时更为精确。 Math.fround()：返回一个数的单精度浮点数形式。 Math.hypot()：返回所有参数平方和的平方根。 Math.expm1(x)：返回e的x次方减1。 Math.log1p(x)：返回1+x的自然对数。以e为底。 Math.log10(x)：返回以10为底的x的对数。 Math.log2()：同上 **：指数运算符。 五 数组的扩展 Array.from()：将类似数组的对象（有length属性）和可遍历对象转化为真正的数组。他还可以接受第二参数，作用类似map方法，用来对每个元素进行处理，将结果放回数组。 Array.of()：将一组值转化为字符串，对比Array()可以生成小于两个参数的数组。 copyWithin()：将指定位置的成员复制到其他位置（会覆盖原有成员），并返回当前数组。三个参数：第一个：从该位置替换数据，第二个：从该位置开始读取数据，第三个：到该位置前停止读取，默认等于数组长度。 find()：他的参数是一个回调函数，找到第一个返回true的成员，返回该成员。没找到返回undefined。 findIndex()：同上，返回该成员的索引，没有找到返回-1。 fill()方法：使用给定值，填充一个数组。第二第三个参数分别是起始位置和结束位置。 entries(),keys(),values()方法：用于遍历数组，key对键名的遍历，values对键值的遍历，entries对键值对的遍历。（一般使用for…of遍历） includes()方法：返回一个布尔值，表示数组是否包含有给定值。与has方法区别：may的has用来查找键名，set的has用来查找键值 六 函数的扩展 函数默认值：function aaa(x,y=”bbb”){}; 函数的length属性：指的是函数参数的个数，如果参数设置了默认值，则该参数以及其后的参数都不计入length中。 函数声明初始化时，参数会形成一个单独的作用域，不设置参数默认值时则不出现。 rest参数：语法：…变量名。将多余参数化作数组。例： function add(…values) { let sum = 0; for (var val of values) { sum += val; } return sum;}add(2, 5, 3) // 10 扩展运算符：语法：…数组。与rest参数相反，将一个数组转为用逗号分隔的参数序列用处：一 替代apply方法：aaa(…[1,2,3]) 等同于 aaa.apply(null,[1,2,3])二 合并数组：[1,2,…more]三 字符串转为数组：[…’hello’]——可以识别32位unicode字符 函数name属性：函数的name属性，返回该函数的函数名 箭头函数：语法：函数名 = 参数值 =&gt; 返回值。如果返回值多于一条语句则用{}括起并用return返回返回值。由于{}解释为代码块所以当返回对象{}的话要用()括起。 七 对象的扩展 Object.is()：同值相等判断，基本等于===，不同于其NaN等于自身，+0不等于-0 Object.assign()：将源对象所有可枚举属性加入目标对象。第一个参数为目标对象，后面的参数全为源对象。 可枚举属性（enumerable）：值为布尔值。for…in等操作会忽视不可枚举属性(false) 对象属性的遍历： for…in：循环遍历对象自身的和继承的可枚举属性 Object.keys(obj)：返回一个数组，包括对象自身的（不含继承）所有可枚举属性的键名。 Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性。 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有Symbol属性 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有属性1到3条都不返回Symbol属性，4，5条则都会返回。 proto属性，Object.setPrototypeof()，Object.getPrototypeOf()：前两个作用相同，用来设置一个对象的prototype对象，返回参数对象本身。（第一个参数为对象，第二个为原型）第三个方法用于读取一个对象的原型对象 Object.keys()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键名。 Object.values()：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性的键值。 Object.entries()：返回一个数组，成员是参数对象自身的（不含继承的）所有可枚举属性的键值对数组。以上三种主要搭配for…of使用。例：for(let [k,v] of Object.entries(xxx)){} Object.getOwnPropertyDescriptors()：返回某个对象属性的描述对象。即返回不显式注明的enumerable等属性。 Null传导运算符（?.）：读取对象内部属性时使用。例：let fn = mes?.body?.user || ‘default’只要任一个属性不存在则不再运算，返回undefined。 八 Symbol 他是js语言的第七种数据类型，用来表示独一无二的值。 Symbol值通过Symbol函数生成。例：let s = Symbol()。该函数可以接受一个字符串作为参数，用来表示对Symbol实例的描述。 使用Symbol值定义属性时，Symbol值必须放在方括号中。否则就代表了字符串而非Symbol值 Symbol.for()：接受一个字符串作为参数，然后搜索是否有以此参数为名的Symbol值。如果有，返回这个值，否则新建并返回一个以该字符串为名称的Symbol值。 Symbol.keyFor()：返回一个已登记Symbol值得key。例：var s1 = Symbol.for(‘foo’);symbol.keyFor(s1) // “foo” Symbol具体的各种属性：… 九 Set和Map数据结构 Set是一种新的数据结构。类似于数组，但成员都是唯一的值。语法：var s = new Set(); 向Set加入值得时候不会发生类型转换。另外两个对象总是不相等的。 Set实例的属性和方法：属性：Set.size：返回set实例的成员总数。方法：Set.add()：添加某个值，返回Set结构本身。Set.delete()：删除某个值，返回一个布尔值，表示删除是否成功。Set.has()：返回一个布尔值，表示该值是否为Set的成员。Set.clear()：清除所有成员，没有返回值。 Array.from()方法可以将Set结构转化为数组。 WeakSet：结构与Set类似，也是不重复的值的集合。不同1：它的成员只能是对象。不同2：它之中的对象都是弱引用，因此它是不可遍历的。 WeakSet的三个方法：.add() .delete() .has() 作用与set的对应方法类似 Map结构：类似于对象，也是键值对的集合，但key的范围不限于字符串。也就是说Object结构提供了字符串-值得对应。map结构提供了值-值的对应。 map的属性和操作方法：属性：size：返回Map结构的成员总数。方法：set(key,value)：设置key所对应的键值，然后返回整个Map结构。get(key)：读取key对应的键值。has(key)： delete(key)： clear()： map的遍历：默认遍历接口entries。keys()、values()、entries()、forEach()。其中map的forEach方法接受第二参数，用来绑定this。即它的回调函数的this只想第二个参数。 与其他数据结构的互相转换 数组：[…map] 数组到map：new Map([xxx,xxx,xxx]) 对象：如果map的键全为字符串，则可以转化为对象。 对象到map：与3相反就行了。 JSON：键名是字符串先转化为对象再用JSON.stringify()转化。键名不是字符串，可以选择转为数组JSON：JSON.stringify([…map]) JSON到map：先转化为对象或数组，再转化为map结构（JSON.parse()） WeakMap：与map结构区别：只接受对象作为键名，且不计入垃圾回收机制，不可遍历。最后，他无法被清空。 十 Proxy和Reflect 先跳过 十一 Promise对象 Promise对象是一个构造函数，用来生成Promise实例，用来保存某个未来才会结束的事件如一个异步操作。语法： var promise = new Promise(function(resolve,reject){ if(异步操作成功：200){resolve(value)}else{reject(error)}}) promise实例的两个参数resolve和reject是两个函数，作用是将对象状态从未完成变为成功或失败。 Promise实例的then方法：指定resolved状态和reject状态的回调函数。promise实例在新建后就立刻执行，then则是在执行完当前脚本所有的同步任务后再输出。 catch方法：用于指定发生错误时的回调函数。一般来说，不在then方法里定义reject回调函数，而用catch。因为状态改变后就不再抛出错误，也无法被catch捕获了。如果没用catch方法指定错误处理的回调函数，Promise实例的错误则不会有任何反应 all方法：语法：var p = Promise.all([p1,p2,p3]);它接受一个数组作为参数，将多个Promise实例，包装成一个新的Promise实例。p的状态由p1、2、3决定，只有全fulfilled，p才会fulfilled。只要有一个rejected，p就rejected。例子： var promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(“/post/“ + id + “.json”);});Promise.all(promises).then(function (posts) {}).catch(function(reason){}); race方法：与all方法相同将多个Promise实例，包装成一个新的Promise实例。p的状态只要有一个实例率先改变状态，p的状态就改变。 resolve方法：将现有对象转化为Promise对象。基本都是转化为resolved状态的promise实例，并立刻执行回调函数。 reject方法：与上面方法相同，不同的是promise实例的状态为rejected 十二 Iterator和for…of循环 Iterator：所有部署了Symbol.iterator属性的数据结构。 Iterator对象除了next方法，还有return和throw方法return函数当for…of循环提前退出时调用（必须返回对象）throw方法一般用不到 for…in只能获得键名，for…of允许遍历获得键值 十三 Generator函数的语法 Generator函数语法：一：function关键字与函数名之间有一个 * 二：函数体内部使用yield语句，定义不同的内部状态。 Generator函数调用方法与普通函数相同，但调用后不执行，返回的也是一个遍历器对象。 需要调用函数必须调用next方法，使指针移向下一个状态。即yield语句是暂停标记，next可以恢复执行。yield与return差别在于它具有记忆位置的功能，下个next会从之前一个yield开始。用过next方法以后返回一个对象，其value属性为yield之后的表达式的值，done属性为函数有没有结束。 yield只能用在generator函数中。且如果要用在表达式中必须用括号括起。 next方法如果带参数则参数就为上一个yield的值。 for…of循环遍历Generator函数：不需要调用next，当done属性为ture循环结束。例如用了return语句。 throw方法：try/catch return方法：返回值并终结generator函数使其done属性变为true，以后再调用next，done属性也总返回true。如果函数内有try…finally代码块，则return会推迟到该代码块加载完在执行 yield语句：默认情况下无法再Generator函数内调用另一个Generator函数，而用`yield`语句后则可以跟Generator函数 Generator函数的this：G函数的总是返回一个遍历器，this函数无法指向该函数。要设定函数内属性要用G.prototype。他也不能用new命令，因为他不是构造函数。要获得正常的this需要用call方法绑定G函数内部的this。例：var f = F.call(F.prototype)。这样就能取到函数内的this了。 十四 Module的语法 export命令：可以输出变量，类和函数。可以用as关键字重命名。 import命令：接受一对大括号，里面指定要从其他模块导入的变量名。也可以用as来重命名 模块整体加载：import * from export default命令：为模块指定默认输出。import可以任意命名。 export与import的复合写法：即先输入后输出同一模块。export {} form ‘’ 模块的继承：export * from &#39;circle&#39;。表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。 跨模块常量：export const A = xxx;多个常量的话：export const db = {url:xxx,name:aaa}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown快速入门]]></title>
      <url>%2F2017%2F04%2F01%2FMarkdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[段落、标题、区块代码 html中的h1到h6标签主要用#来表示，有几个#就表示是几级标题 段落的话可以用“&gt;”开头，也可以不用。不用的话会将整段话用p标签括起 换行：两个空格加回车，或者直接用br标签修饰和强调Markdown使用星号或下划线括起一段文字来标记强调区域。星号代表em标签，下划线代表strong标签例子：我要被强调啦 我又要被强调啦 列表 无序列表用星号、加号和减号来作为项目标记例： 项目1 项目2 项目3 有序列表用一个数字再加一个英文据点作为项目标记 如果你在项目之间插入空行，那项目的内容会用 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排4个空白或1个tab。 链接 行内形式：[里面放a标签的内容](里面放链接&quot;里面放title属性&quot;)例：这个是本文地址参考链接 参考形式：懒得看了，就用行内形式吧 图片图片的语法和链接很像，我就只列出行内形式了（无法改变图片宽高，要么你就用img标签）语法：![这里放alt信息](这里放图片地址&quot;这里放title&quot;)例：关于图片的地址把图片放在images文件夹内，图片地址为../../../../images 代码使用反引号括起代码区域，就是左上角波浪线呢个键 表格 写法：|姓名|年龄|描述| |:-|-:|:-:| |勒布朗·詹姆斯|32|nba超级巨星，现役最伟大球星| |luffy|321233444|要成为海贼王的男人| |王尼玛|0|污男| 效果：|姓名|年龄|描述||:-|-:|:-:||勒布朗·詹姆斯|32|nba超级巨星，现役最伟大球星||luffy|321233444|要成为海贼王的男人||王尼玛|0|污男| 缩进一般md不支持缩进。可以通过转化输入法为全角再用空格缩进。转化全角方法：shift+space]]></content>
    </entry>

    
  
  
</search>
